\chapter{Técnicas de visión computerizada}
Aquí se detallan todas las técnicas aplicadas o descartadas a lo largo
de la investigación. Incluye ejemplos de las tomografías para poder
relacionar la técnica con el resultado visual.\\
Toda la información presente en este capítulo ha sido redactada acorde
a las siguientes fuentes:
% TODO: Falta añadir bibliografías de Learn OpenCV, el tutorial de
% Python y la API

\section{Conocimientos previos necesarios}

\subsection{Histogramas}
Un histograma es un gráfico con la distribución de color o
intensidades de la imagen, por simplificación, suponemos siempre una
imagen en escala de grises. Es tan importante su estudio dentro de la
visión computerizada que se podría definir informalmente como el
gráfico que contiene la naturaleza de la imagen.
\begin{description}
\item[Columnas:] representan intensidades. Cada columna tiene una
  altura que corresponde proporcionalmente a la cantidad de píxeles
  con dicho valor.
\item[Dimensiones:] parámetros o número de datos a mostrar en el
  histograma. En el caso de una escala de grises sólo hay una
  dimensión, la intensidad, que puede ser 1 si el píxel tiene dicha
  intensidad o 0 en caso contrario.
\item[Rango:] es el número de columnas. En escala de grises el rango
  es de 256 columnas desde 0 hasta 255.
\end{description}

\subsubsection{Cálculo}
Para realizar el cálculo de un histograma y por simplificación se usa
una biblioteca. Tanto \emph{Numpy} como \emph{OpenCV} son capaces de
realizar los cálculos necesarios pero por eficiencia se usa
\emph{OpenCV}.

\subsubsection{Dibujado}
El resultado de un histograma es una matriz de \emph{Numpy} por lo
que, para poder dibujarla, tiene que usarse \emph{Matplotlib} o
transformar la matriz en una imagen de \emph{OpenCV}.

\subsubsection{Ecualización}
La ecualización de un histograma consiste en distribuir los píxeles
por todo el rango. Esta acción aumenta el contraste en aquellas
imágenes que tienen la mayoría confinados en una zona pequeña del
rango.

\subsection{Convolución de matrices}
La \emph{convolución} de una matriz sobre una imagen, que al fin y al
cabo es otra matriz, es la principal base de la mayoría de las
técnicas aquí descritas. \\
Un \emph{kernel} es una matriz fija de coeficientes numéricos y
dimensión \textbf{impar} que se usa en todas las técnicas de este
capítulo
para tener un elemento como el elemento central. \\
Para calcular la convolución de un píxel concreto se sitúa éste en el
centro del \emph{kernel} y se calcula su valor con respecto a los
píxeles de alrededor, multiplicando su valor por el valor del
\emph{kernel} para esa posición. Finalmente, cada multiplicación se
suma y se guarda el resultado total en la posición central. Este
proceso se repite con cada píxel. \\
La ecuación que representa el proceso anterior, definiendo la imagen
como $I(x, y)$, el \emph{kernel} como $K(i, j)$ (donde
$0 < i < M_j - 1$ y $0 < j < M_j - 1$) y el centro de la matriz de
convolución es $(c_i, c_j)$ definimos la imagen resultante como
\begin{equation*}
  R(x, y) = \sum_{i=0}^{M_i-1} \sum_{j=0}^{M_j-1}  I(x + i - c_i, y + j - c_j)K(i,j)
\end{equation*}
En el caso de \emph{OpenCV}, tanto la imagen original \emph{I} como la
imagen resultante \emph{R} son del mismo tamaño. Esto se debe a que
\emph{OpenCV} duplica el borde de manera virtual para que el
\emph{kernel} de convolución se pueda aplicar hasta el mismo borde de
la imagen. Hay distintas maneras de duplicar el borde pero aquí sólo
se muestra la más simple y sobre el eje de abscisas:
\begin{center}
  $imagen(-dx, y) = imagen(0, y)$
  \\
  $imagen(w + dx) = imagen(w - 1, y)$
\end{center}


\section{Operaciones básicas}
\subsection{Acceso a píxeles}
El acceso a los píxeles de una imagen se realiza a través de
\emph{Numpy} como una matriz de dimensiones [\emph{y}, \emph{x}],
siendo \emph{y} la altura y \emph{x} el ancho.
\begin{minted}{Python}
  pixel = imagen[y, x]
\end{minted}

\subsection{Propiedades}
Las dos propiedades más utilizadas de las imágenes son su altura y
anchura.  Se pueden obtener con la función \emph{shape}.
\begin{minted}{Python}
  y, x = imagen.shape
\end{minted}

\subsection{Región de interés}
La región de interés (ROI) de una imagen es la zona que estamos
interesados en procesar. Se expresa mediante los vértices opuestos de
un rectángulo o cuadrado definidos como los píxeles [$y_1$, $x_1$] y
[$y_2$,$x_2$] de la imagen
\begin{minted}{Python}
  roi = imagen[y1:y2, x1:x2]
\end{minted}

\section{Operaciones aritméticas}
\subsection{Superposición}
La superposición de dos imágenes (del mismo tipo, profundidad o una
que sea un valor escalar) es la suma matricial de sus píxeles,
asignando a cada imagen un peso diferente para dar la sensación de
superposición y transparencia. La función sería:
\begin{equation*}
  g(n) = (1 - \alpha)f_0(n) + \alpha f_1(n)
\end{equation*}
Donde \emph{n} representa un punto de la imagen, \emph{$\alpha$} es una
constante entre 0 y 1, y \emph{$f_0$} y \emph{$f_1$} las imágenes.
Expresado en forma de coordenadas:
\begin{equation*}
  g(x, y) = (1 - \alpha)f_0(x, y) + \alpha f_1(x, y)
\end{equation*}
Donde \emph{x} e \emph{y} representan las coordenadas (horizontal y
vertical respectivamente).


\section{Cambio de espacio de color}
Un espacio de color es un modelo matemático abstracto que describe la
forma en la que los colores pueden representarse como tuplas de
números. RGB, HSV o escala de grises son ejemplos de espacios de color. \\
El espacio de color de una imagen se puede cambiar con la función
\emph{cvtColor}. Esta función permite las siguientes conversiones en
las dos direcciones:
\begin{itemize}
\item \textbf{RGB} --- \textbf{escala de grises}.
\item \textbf{RGB} --- \textbf{CIE XYZ}.
\item \textbf{RGB} --- \textbf{YCrCb JPEG} (o YCC).
\item \textbf{RGB} --- \textbf{HSV}.
\item \textbf{RGB} --- \textbf{HLS}.
\item \textbf{RGB} --- \textbf{Bayer}.
\end{itemize}
Estas transformaciones permiten la detección rápida y sencilla de
características de interés. \\
Para este proyecto se han usado las que implican RGB y escala de
grises.

\section{Operaciones de \emph{threshold}}
Las operaciones de \emph{threshold} convierten los píxeles de una
imagen (en escala de grises [0 --- 255]) superiores a un valor,
conocido como valor de umbral, a blanco [255] o a negro [0], según el
\emph{threshold} aplicado.
\subsection{Simples}
\subsubsection{cv2.THRESH\_BINARY o \emph{Binarización}}
Todos los píxeles con un valor mayor que el valor de umbral se
transforman, asignándoles el valor máximo. Los que no lo superen,
adquieren el valor mínimo.  La expresión es
\begin{equation*}
  destino(x, y) =
  \begin{cases}
    255 & \text{si } entrada(x, y) > umbral \\
    0 & \text{cualquier otro caso}
  \end{cases}
\end{equation*}
Ejemplo para un valor de umbral de 127 (Arriba original y abajo el
resultado obtenido tras aplicar el filtro):

\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdOriginal.png}\\
\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdBinary_127.png}

\subsubsection{cv2.THRESH\_BINARY\_INV o \emph{Binarización inversa}}
Es la operación contraria al anterior: a los píxeles con un valor
mayor que el valor de umbral se les asigna el valor mínimo, mientras
que los demás adquieren el valor máximo. La expresión es
\begin{equation*}
  destino(x, y) =
  \begin{cases}
    0 & \text{si } entrada(x, y) > umbral \\
    255 & \text{cualquier otro caso}
  \end{cases}
\end{equation*}
Ejemplo para un valor de umbral de 127 (Arriba original y abajo el
resultado obtenido tras aplicar el filtro):

\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdOriginal.png}\\
\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdBinaryInv_127.png}


\subsubsection{cv2.THRESH\_TRUNC o \emph{Truncamiento}}
Se trunca el valor de los píxeles de forma que todos los píxeles que
superen el valor de umbral toman dicho valor. En caso contrario se
conserva el valor original. La expresión es
\begin{equation*}
  destino(x, y) =
  \begin{cases}
    umbral & \text{si } entrada(x, y) > umbral \\
    entrada(x, y) & \text{cualquier otro caso}
  \end{cases}
\end{equation*}
Ejemplo para un valor de umbral de 127 (Arriba original y abajo el
resultado obtenido tras aplicar el filtro):

\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdOriginal.png}\\
\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdTrunc_127.png}


\subsubsection{cv2.THRESH\_TOZERO}
Es la operación contraria a la anterior: los píxeles que superen el
valor del umbral conservan su valor original, mientras que en el caso
contrario se les aplica el valor mínimo. La expresión es
\begin{equation*}
  destino(x, y) =
  \begin{cases}
    entrada(x, y) & \text{si } entrada(x, y) > umbral \\
    0 & \text{cualquier otro caso}
  \end{cases}
\end{equation*}
Ejemplo para un valor de umbral de 127 (Arriba original y abajo el
resultado obtenido tras aplicar el filtro):

\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdOriginal.png}\\
\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdTo0_127.png}


\subsubsection{cv2.THRESH\_TOZERO\_INV}
A los píxeles que superen el valor de umbral se les aplica el valor
mínimo, mientras que en caso contrario conservan el valor original. La
expresión es
\begin{equation*}
  destino(x, y) =
  \begin{cases}
    0  & \text{si } entrada(x, y) > umbral \\
    entrada(x, y) & \text{cualquier otro caso}
  \end{cases}
\end{equation*}
Ejemplo para un valor de umbral de 127 (Arriba original y abajo el
resultado obtenido tras aplicar el filtro):

\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdOriginal.png}\\
\includegraphics[scale=0.40]{imagenes/EjemploTecnicasThresholdTo0Inv_127.png}

\subsection{Adaptativos}
En imágenes uniformes aplicar valores umbral globales y fijos suele
ser una buena opción pero para imágenes no uniformes hay que adaptar
dicho valor a cada área de la imagen. Por ello, se aplican las dos
técnicas siguientes. En ambas, el área a realizar el \emph{threshold}
depende del tamaño del \emph{kernel} usado.

\subsubsection{cv2.ADAPTIVE\_THRESH\_MEAN\_C}
El valor de cada píxel se establece por la media de sus vecinos.

\subsubsection{cv2.ADAPTIVE\_THRESH\_GAUSSIAN\_C}
El valor de cada píxel se establece por el resultado de una función
Gaussiana a partir de sus vecinos.

\subsection{ Otsu}
Este \emph{threshold} calcula el valor umbral a partir del histograma
de la imagen. La precisión de esta técnica depende de que el
histograma sea lo más bimodal posible, en los que predomina dos
columnas.

\section{Transformaciones geométricas}
Las transformaciones geométricas son aquellas técnicas en las que se
aplica una matriz o \emph{kernel} de transformación a la imagen
original.
\subsection{Rotación}
Para rotar una imagen desde un ángulo $\theta$ se opera con la siguiente
matriz de transformación.
\begin{equation*}
  M =
  \begin{bmatrix}
    \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta
  \end{bmatrix}
\end{equation*}
\emph{OpenCV} además, facilita una matriz de rotación escalable con
centro ajustable para el punto que se prefiera.
\begin{equation*}
  \begin{bmatrix}
    \alpha & \beta & (1 - \alpha) \cdot centro_x - \beta \cdot centro_y \\
    - \beta & \alpha & \beta \cdot centro_x + (1 - \alpha) \cdot centro_y
  \end{bmatrix}
\end{equation*}
donde:
\begin{center}
  $ \alpha = escala \cdot \cos \theta $
  \\
  $ \beta = escala \cdot \sin \theta $
\end{center}
Para facilitar todavía más la rotación, \emph{OpenCV} proporciona la
función
\begin{center}
  \textbf{cv2.getRotationMatrix2D}(centro, ángulo, escala) \\
  $\downarrow$ \\
  matriz de transformación
\end{center}
Posteriormente hay que aplicar la función de afinidad con la matriz de transformación anterior \\
\begin{center}
  \textbf{cv2.warpAffine}(imagen, matriz, tamaño)\\
  $\downarrow$ \\
  imagen destino
\end{center}

\section{\emph{Blur}}
\emph{Blur} o suavizado es una técnica usada con el objetivo principal
de reducir el ruido y los artefactos (contenido de alta frecuencia) de
la imagen, aunque también se usa para disminuir la resolución. Se basa
en aplicar a la imagen un \emph{kernel} de convolución.
\subsection{Basado en la media}
En el caso de un \emph{blur}, se suman todos los valores de los
píxeles contenidos en la matriz y se divide entre el número de
vecinos. El \emph{kernel} a aplicar es el siguiente
\begin{equation*}
  K = \frac{1}{n}
  \begin{bmatrix}
    1_{11} & 1_{12} & \cdots & 1_{1n} \\
    1_{21} & 1_{22} & \cdots & 1_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    1_{n1} & 1_{n2} & \cdots & 1_{nn} \\
  \end{bmatrix}
  \text{siendo \emph{n} un número impar}
\end{equation*}

A modo de ejemplo, el \emph{kernel} de dimensión $3\times3$ es
\begin{equation*}
  K = \frac{1}{9}
  \begin{bmatrix}
    1 & 1 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1 \\
  \end{bmatrix}
\end{equation*}
\subsection{Basado en una función Gaussiana}
Esta técnica es la que mejor resultados suele dar y especialmente si
se utiliza para reducir ruido generado por un \emph{kernel
  Gaussiano}. Cabe destacar que al aplicar este método puede darse
como resultado valores de píxeles que no estuvieran en la imagen
original. Este \emph{Blur} es el menos eficiente de todos pero
\emph{OpenCV} lo optimiza para las sigmas $\sigma_x$ e $\sigma_y$
predeterminadas para los \emph{kernels} de $3\times3$, $5\times5$ y
$7\times7$. Debido a esto, sólo mostraremos como se
generan estas sigmas predeterminas y un ejemplo con ellas.\\
\emph{OpenCV} obliga a introducir $\sigma_x$ y en el caso de que este sea 0,
se determinan ambos sigmas a partir del tamaño del \emph{kernel}
introducido mediante las fórmulas siguientes:
\begin{equation*}
  \sigma_x = \left(\frac{n_x}{2} - 1 \right) \cdot 0,30 + 0.80, n_x = \text{anchura del \emph{kernel}}
\end{equation*}
\begin{equation*}
  \sigma_y = \left(\frac{n_y}{2} - 1 \right) \cdot 0,30 + 0.80, n_y = \text{altura del \emph{kernel}}
\end{equation*}
Y la función \emph{Gaussiana} en la que se aplican:
\begin{equation*}
Gaussiana(x, y) = \frac{1}{\sqrt{2 \pi \sigma^{2}}}e^{- \frac{x^{2}+y^{2}}{2\sigma^{2}}}
\end{equation*}


\subsection{Basado en la mediana}
En el caso de un \emph{median Blur} y como oposición al \emph{Blur},
que se basa en la media, el \emph{median Blur} calcula el valor
del píxel central mediante la mediana de los píxeles colindantes. \\
Esta técnica es muy útil para reducir el ruido granulado de la imagen.

\section{Transformaciones morfológicas}
Las operaciones de transformación morfológicas se aplican sobre la
forma de la imagen. Se suelen usar para reducir el ruido, aislar o
juntar elementos. El \emph{kernel} aplicado a la imagen define el
resultado de la operación. \\
Normalmente, este tipo de operaciones se realizan posteriormente a una
operación de \emph{threshold} por lo que para entender mejor la
operación supondremos que la imagen está \emph{binarizada} (píxeles
únicamente blancos o negros). \\
A diferencia de los \emph{kernel} de convolución, los \emph{kernel}
morfológicos no necesitan ser de dimensión cuadrada ni contener
valores numéricos porque se utilizan como referencia para indicar las
posiciones de los píxeles.
\subsection{\emph{Erosion}}
Es una técnica que usa un \emph{kernel} a modo de máscara, sustituye
el píxel central por el \emph{mínimo local} de sus vecinos. Si algún
vecino es un píxel negro, automáticamente el píxel central se
convertirá en negro. El nombre procede del efecto que produce en una
imagen un artefacto blanco sobre fondo negro dando la sensación de
reducción del artefacto y reduciendo sus salientes. La fórmula es:
\begin{equation*}
  erode(x, y) = \min_{\substack{(x', y' \in kernel)}} imagen(x + x', y + y')
\end{equation*}

\subsection{\emph{Dilation}}
Es la técnica inversa a \emph{Erosion}, de la misma manera un
\emph{kernel} a modo de máscara sustituye el píxel central por el
\emph{máximo local}. Si alguno de sus vecinos es un píxel blanco, el
central automáticamente se convertirá en blanco. Igualmente, el nombre
procede del efecto que produce en una imagen con un artefacto blanco
sobre fondo negro dando la sensación de la dilatación del artefacto y
reduciendo sus concavidades. La fórmula es:
\begin{equation*}
  dilate(x, y) = \max_{\substack{(x', y' \in kernel)}} imagen(x + x', y + y')
\end{equation*}

\subsection{\emph{Opening}}
La técnica de \emph{Opening} consiste en la realización de un
\emph{Erode} seguido de un \emph{Dilate}. Se utiliza para la
eliminación de ruido granulado alrededor del artefacto.

\subsection{\emph{Closing}}
La técnica de \emph{Closing} consiste en la realización de un
\emph{Dilate} seguido de un \emph{Erode}. Se utiliza para la
eliminación de ruido granulado situado en el interior del artefacto.

\subsection{Gradiente morfológico}
Es la diferencia entre la operación \emph{Dilation} y la operación
\emph{Erode} de la imagen. Se utiliza para marcar el perímetro o borde
del artefacto. La expresión es:
\begin{equation*}
  gradiente(imagen) = dilate(imagen) - erode(imagen)
\end{equation*}

\section{Gradientes}
El cálculo de gradientes o bordes se realiza mediante la convolución
de derivadas parciales del estilo:
\begin{equation*}
  \frac{\delta^{2}}{\delta x \delta y}
\end{equation*}
Por simplificación y eficiencia nos centraremos en describir sus
aproximaciones, más fáciles de entender. \\
El origen de los números de los \emph{kernels} se basa en el siguiente
proceso:\\
Una imagen se puede representar como una función de una señal continua y
discreta. Nos centraremos en ver el proceso con una fila de píxeles de
la imagen. Un borde es un cambio de color que en la función está
representado como un cambio de valor entre una posición y
otra. Matemáticamente la manera de medir cuánto cambia entre un punto
por ejemplo $x$ y otro muy próximo $x + \delta x$ se realiza mediante la
derivación.\\
La fórmula para derivar una imagen $I$ que sólo contenga una fila de
píxeles es siguiente:
\begin{equation*}
I'_x(x) = \lim_{\delta x \to 0}\frac{I(x+\delta x) - I(x)}{\delta x}
\end{equation*}
Como sólo se pueden computar valores discretos, el punto de la función
más cercano a $0$ es $\delta x = 1$. Esto aproxima la derivada a
\begin{equation*}
I_x'(x) \approx I(x + 1) - I(x)
\end{equation*}
Si extraemos los coeficientes de las imágenes a un \emph{kernel} el
resultado es
\begin{equation*}
kernel = \begin{bmatrix}
1 & -1
\end{bmatrix}
\end{equation*}
Nótese que la suma de todos los coeficientes siempre será $0$. Para
alargar alargar el \emph{kernel} y abarcar más píxeles por ejemplo
tres se procede a introducir $0$ entre medias dando lugar a
$\begin{bmatrix} 1 & 0 & -1 \end{bmatrix}$ \\
Al realizar la primera derivada, nos encontramos que para interpretar
el gradiente tiene que ser un máximo local y suficientemente alto para
distinguirlo. Por lo que si aplicamos segunda derivada suavizamos el
gradiente y obtenemos de manera precisa el máximo local porque toma el
valor $0$ en el eje de abcisas. Si alargamos el \emph{kernel} en los
ejes $x, y$ obtendremos el \emph{kernel}
\emph{Sobel} que se explicará con detenimiento en el siguiente apartado. \\
La segunda derivada viene dada por:
\begin{equation*}
  I''(x) = \lim_{\delta x \to 0}\frac{I'(x+\delta x) - I'(x)}{\delta x}
\end{equation*}
Si aproximamos como la vez anterior $\delta x = 1$ obtenemos
\begin{equation*}
  I_x''(x) \approx I'(x + 1) - I'(x)
\end{equation*}
Como ya hemos aproximado la primera derivada:
\begin{equation*}
  I'(x) \approx I(x + 1) - I(x)
\end{equation*}
Podemos aplicarla a la segunda
\begin{equation*}
  I''(x) \approx \underbrace{I'(x + 1)}_{I(x + 2) - I(x + 1)} - \underbrace{I'(x)}_{I(x + 1) - I(x)}
\end{equation*}
Dando como resultado:
\begin{equation*}
  I''(x) \approx I(x) - 2I(x + 1) + I(x + 2)
\end{equation*}
Y al \emph{kernel} $\begin{bmatrix} 1 & -2 & 1 \end{bmatrix}$
presentando el siguiente apartado
\subsection{Sobel}
Como el operador \emph{Sobel} está definido en un espacio discreto no
es exactamente una derivada, representa un polinomio y la segunda
derivada, una función parabólica. Por esta razón, cuanto más grande y
más píxeles abarque el \emph{kernel} mejor aproximación se obtiene y
más tolerancia al ruido.
\begin{center}
  $ G_x = \begin{bmatrix}
    -1 & 0 & +1 \\
    -2 & 0 & +2 \\
    -1 & 0 & +1 \\
  \end{bmatrix}
  \hspace{0.5cm} \text{ y } \hspace{0.5cm} G_y = \begin{bmatrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    +1 & +2 & +1 \\
  \end{bmatrix}
  $
  \\[0.5cm]
  $G = \sqrt{G_x\,^2 + G_y\,{2}}$
  \\[0.5cm]
  $\Theta= \arctan\left(\frac{G_y}{G_x} \right)$
\end{center}
La aproximación con el \emph{kernel} se hace de la siguiente manera:
\begin{equation*}
  Sobel(imagen) = \frac{\delta^{orden_x + orden_y} imagen}{\delta x^{orden_x} \delta
    y^{orden_y}} \text{siendo el orden de derivación } orden_y \text{ y } orden_y > 0
\end{equation*}

\subsection{Scharr}
El operador \emph{Scharr} se utiliza como el sustituto del operador
\emph{Sobel} cuando es necesario aplicar \emph{kernels} pequeños
especialmente de tamaño $3 \times 3$ en los cuales al tener tan pocos
píxeles, los bordes no suelen estar posicionados sobre los ejes $x$ e
$y$ como en la superficie de los \emph{kernel} de gran tamaño siendo
la aproximación de \emph{Sobel} bastante inexacta con los gradientes
en forma de ángulo.
\begin{center}
  $ G_x = \begin{bmatrix}
    +3 & 0 & -3 \\
    +10 & 0 & -10 \\
    +3 & 0 & -3 \\
  \end{bmatrix}
  \hspace{0.5cm} \text{ y } \hspace{0.5cm} G_y = \begin{bmatrix}
    +3 & +10 & +10 \\
    0 & 0 & 0 \\
    -3 & -10 & -10 \\
  \end{bmatrix}
  $
\end{center}
\subsection{Laplaciano}
El operador \emph{Laplaciano} se define como la segunda derivada del
operador \emph{Sobel} de la siguiente manera:
\begin{equation*}
  Laplaciana(imagen) = \frac{\delta^{2} imagen}{\delta x^{2}} + \frac{\delta^{2} imagen}{\delta y^{2}}
\end{equation*}
Por motivos de eficiencia, se aproxima con el \emph{kernel} siguiente
\begin{center}
  $ kernel = \begin{bmatrix}
    0 & +1 & 0 \\
    +1 & -4 & +1 \\
    0 & +1 & 0 \\
  \end{bmatrix}
  $
\end{center}

\section{Algoritmo \emph{Canny}}
El \emph{Canny} es un algoritmo de detección de bordes conocido como
el \emph{detector óptimo} con la función de satisfacer tres criterios
principales:
\begin{itemize}
\item Bajo índice de error.
\item Minimización de la distancia entre los bordes detectados y los
  reales.
\item Un único detector por borde.
\end{itemize}
Para ello lo primero que hace es descartar el ruido usando el filtro
Gaussiano.
El \emph{kernel} usado para este filtro no es fijo.\\
Luego encuentra la intensidad del gradiente de la imagen con
procedimiento similar al Sobel con las mismas máscaras de convolución,
fuerza del gradiente
y dirección:\\
\subsection{Sobel}
\begin{center}
  $ G_x = \begin{bmatrix}
    -1 & 0 & +1 \\
    -2 & 0 & +2 \\
    -1 & 0 & +1 \\
  \end{bmatrix}
  \hspace{0.5cm} \text{ y } \hspace{0.5cm} G_y = \begin{bmatrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    +1 & +2 & +1 \\
  \end{bmatrix}
  $
  \\[0.5cm]
  $G = \sqrt{G_x\,^2 + G_y\,{2}}$
  \\[0.5cm]
  $\Theta= \arctan\left(\frac{G_y}{G_x} \right)$
\end{center}
Posteriormente, se suprimen los píxeles que no se consideran parte del
borde de forma que solo queden unas finas líneas. Estas líneas son los posibles bordes.\\
Por último, se usan dos \emph{thresholds}, uno alto y uno bajo: Si el
gradiente del píxel es mayor que el threshold alto, el píxel formará
parte del borde; si el gradiente del píxel es menor que el threshold
bajo, no se tendrá en cuenta; en caso de que el gradiente del píxel
esté entre ambos \emph{thresholds} se considerará solo si está
contiguo a un píxel cuyo gradiente sea superior al threshold alto.

\section{Contornos}

\section{Transformada de \emph{Hough}}
La transformada de \emph{Hough} es una técnica que se aplica para
encontrar formas en una imagen incluso a pesar de ruido siempre que se
puedan expresar matemáticamente como líneas rectas y curvas. Nos
centraremos sólo en explicar las primeras.
\subsection{Rectas}
Cualquier punto de una imagen \emph{binarizada} puede formar parte de
una línea recta. Representamos una recta como
\begin{equation*}
  y = mx +c
\end{equation*}
O de forma paramétrica
\begin{equation*}
  \rho = x \cos \theta + y \sin \theta
\end{equation*}
donde $\rho$ es la distancia perpendicular a la recta desde el origen y
$\theta$ el ángulo que forman la recta de la distancia con el
origen. En \emph{OpenCV} el origen está situado en la parte superior
izquierda. Si la recta a dibujar corta al eje de abcisas con un valor
positivo el ángulo $\theta$ es menor que $180º$ y el valor de $\rho$
es positivo. Por el contrario, si corta al eje de abcisas por un valor
negativo, el ángulo $\theta$ es mayor de $180º$ y $\rho$ es
negativo. Los casos extremos son las líneas verticales $0º$ y
horizontales $90º$.
\section{Puntos de interés o \emph{Blobs}}